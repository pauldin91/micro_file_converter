// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: uploads.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUpload = `-- name: CreateUpload :one
INSERT INTO uploads (user_email, status)
VALUES ($1,COALESCE($2, 'QUEUED'))
RETURNING  id, user_email, status, created_at, created_by, updated_at, updated_by
`

type CreateUploadParams struct {
	UserEmail string      `json:"user_email"`
	Column2   interface{} `json:"column_2"`
}

type CreateUploadRow struct {
	ID        uuid.UUID    `json:"id"`
	UserEmail string       `json:"user_email"`
	Status    UploadStatus `json:"status"`
	CreatedAt time.Time    `json:"created_at"`
	CreatedBy string       `json:"created_by"`
	UpdatedAt time.Time    `json:"updated_at"`
	UpdatedBy string       `json:"updated_by"`
}

func (q *Queries) CreateUpload(ctx context.Context, arg CreateUploadParams) (CreateUploadRow, error) {
	row := q.db.QueryRow(ctx, createUpload, arg.UserEmail, arg.Column2)
	var i CreateUploadRow
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteUploadByEmail = `-- name: DeleteUploadByEmail :one
DELETE FROM uploads
WHERE user_email = $1
RETURNING  id, user_email, status, created_at, created_by, updated_at, updated_by
`

type DeleteUploadByEmailRow struct {
	ID        uuid.UUID    `json:"id"`
	UserEmail string       `json:"user_email"`
	Status    UploadStatus `json:"status"`
	CreatedAt time.Time    `json:"created_at"`
	CreatedBy string       `json:"created_by"`
	UpdatedAt time.Time    `json:"updated_at"`
	UpdatedBy string       `json:"updated_by"`
}

func (q *Queries) DeleteUploadByEmail(ctx context.Context, userEmail string) (DeleteUploadByEmailRow, error) {
	row := q.db.QueryRow(ctx, deleteUploadByEmail, userEmail)
	var i DeleteUploadByEmailRow
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getAllUploads = `-- name: GetAllUploads :many
SELECT  id, user_email, status, created_at, created_by, updated_at, updated_by
FROM uploads
ORDER BY created_at
LIMIT $1
OFFSET $2
`

type GetAllUploadsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllUploadsRow struct {
	ID        uuid.UUID    `json:"id"`
	UserEmail string       `json:"user_email"`
	Status    UploadStatus `json:"status"`
	CreatedAt time.Time    `json:"created_at"`
	CreatedBy string       `json:"created_by"`
	UpdatedAt time.Time    `json:"updated_at"`
	UpdatedBy string       `json:"updated_by"`
}

func (q *Queries) GetAllUploads(ctx context.Context, arg GetAllUploadsParams) ([]GetAllUploadsRow, error) {
	rows, err := q.db.Query(ctx, getAllUploads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUploadsRow{}
	for rows.Next() {
		var i GetAllUploadsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Status,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUploadByEmail = `-- name: GetUploadByEmail :one
SELECT  id, user_email, status, created_at, created_by, updated_at, updated_by
FROM uploads
WHERE user_email = $1
`

type GetUploadByEmailRow struct {
	ID        uuid.UUID    `json:"id"`
	UserEmail string       `json:"user_email"`
	Status    UploadStatus `json:"status"`
	CreatedAt time.Time    `json:"created_at"`
	CreatedBy string       `json:"created_by"`
	UpdatedAt time.Time    `json:"updated_at"`
	UpdatedBy string       `json:"updated_by"`
}

func (q *Queries) GetUploadByEmail(ctx context.Context, userEmail string) (GetUploadByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUploadByEmail, userEmail)
	var i GetUploadByEmailRow
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getUploadByEmailWithDocuments = `-- name: GetUploadByEmailWithDocuments :many
SELECT  u.id, u.user_email, u.status, u.created_at, u.created_by, u.updated_at, u.updated_by, d.name, d.pages, d.upload_id
FROM uploads u
JOIN files d ON u.id = d.upload_id
WHERE u.user_email = $1
`

type GetUploadByEmailWithDocumentsRow struct {
	ID        uuid.UUID    `json:"id"`
	UserEmail string       `json:"user_email"`
	Status    UploadStatus `json:"status"`
	CreatedAt time.Time    `json:"created_at"`
	CreatedBy string       `json:"created_by"`
	UpdatedAt time.Time    `json:"updated_at"`
	UpdatedBy string       `json:"updated_by"`
	Name      string       `json:"name"`
	Pages     pgtype.Int4  `json:"pages"`
	UploadID  uuid.UUID    `json:"upload_id"`
}

func (q *Queries) GetUploadByEmailWithDocuments(ctx context.Context, userEmail string) ([]GetUploadByEmailWithDocumentsRow, error) {
	rows, err := q.db.Query(ctx, getUploadByEmailWithDocuments, userEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUploadByEmailWithDocumentsRow{}
	for rows.Next() {
		var i GetUploadByEmailWithDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Status,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Name,
			&i.Pages,
			&i.UploadID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUpload = `-- name: UpdateUpload :one
UPDATE uploads
SET status = $2, updated_at = NOW()
WHERE user_email = $1
RETURNING  id, user_email, status, created_at, created_by, updated_at, updated_by
`

type UpdateUploadParams struct {
	UserEmail string       `json:"user_email"`
	Status    UploadStatus `json:"status"`
}

type UpdateUploadRow struct {
	ID        uuid.UUID    `json:"id"`
	UserEmail string       `json:"user_email"`
	Status    UploadStatus `json:"status"`
	CreatedAt time.Time    `json:"created_at"`
	CreatedBy string       `json:"created_by"`
	UpdatedAt time.Time    `json:"updated_at"`
	UpdatedBy string       `json:"updated_by"`
}

func (q *Queries) UpdateUpload(ctx context.Context, arg UpdateUploadParams) (UpdateUploadRow, error) {
	row := q.db.QueryRow(ctx, updateUpload, arg.UserEmail, arg.Status)
	var i UpdateUploadRow
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
